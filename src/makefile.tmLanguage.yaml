# yaml-language-server: $schema=https://json.schemastore.org/tmlanguage.json
---

name: make
scopeName: source.makefile

patterns:

- include: "#comment"

- include: "#expansions"

- include: "#variable-assignment"

- include: "#directives"

- include: "#recipe-line"

- include: "#rulehead"


repository:


# ----------------------- misc. anchors ----------------------- #

  __miscAnchors:

    patterns:

    - match: &SCOPE_lineCont >-
        punctuation.separator.continuation.makefile
        constant.character.escape.continuation.makefile
        constant.character.escape.line-continuation.makefile

    - match: &SCOPE_var >-
        variable.other.makefile
        variable.other.string.makefile

    - match: &SCOPE_varAsgn >-
        variable.other.assignment.makefile

    - match: &SCOPE_recipe__ >-
        meta.scope.recipe.makefile

    - match: &SCOPE_recipeLN >-
        meta.scope.recipe.line.makefile

    # currently unused:
    - match: &SCOPE_recipeRH >-
        meta.scope.recipe.rulehead.makefile


# ------------------------ misc. rules ------------------------ #

  esc-backslashes:
    comment: TODO

  doubleDollar:
    match: (\$\$)+
    name: constant.character.escape.dollar.makefile

  comma:
    match: ","
    name: punctuation.separator.delimeter.comma.makefile

  comment:
    patterns:
    - include: "#quoted-hash"
    - include: "#comment-actual"
    repository:
      comment-actual:
        begin: |-
          (?x)
          (     ^[ ]+        )?  # "1": any whitespaces at beginning of line
          (?<!  \\           )   # otherwise unreliable \ count -> don't match
          (     (?: \\ \\)*  )   # "2": any even no. of \-s -> quoting \-es
          (?=   \#           )   # an (unquoted) # on next position
        beginCaptures:
          "1": { name: punctuation.whitespace.comment.leading.makefile }
          "2": { name: constant.character.escape.backslash.makefile }
        end: (?!\G)
        patterns:
        - begin: \#
          beginCaptures:
            "0": { name: punctuation.definition.comment.makefile }
          end:   (?<!\\)(?=\n)
          name: comment.line.number-sign.makefile
          patterns:
          - { match: \\$, name: *SCOPE_lineCont }
      quoted-hash:
        match: |-
          (?x)
          (?<!    \\        )   # otherwise unreliable \ count -> don't match
          (   (?: \\{2} )*  )   # "1": any even no. of \-s -> quoting \-es
                 (\\)(\#)       #    : the quoted #
        captures:
          "1": { name: constant.character.escape.backslash.makefile }
          "2": { name: constant.character.escape.backslash.makefile }
          "3": { name: meta.escaped-char.makefile }

  line-cont:
    comment: |-
      TODO

  percent:
    comment: TODO

  wildcard:
    comment: TODO


# ------------------------- directives ------------------------ #

  directives:

    patterns:
    - include: "#include-directive"
    - include: "#vpath"
    - include: "#define"
    - include: "#export"
    - include: "#override_private"
    - include: "#unexport_undefine"
    - include: "#conditional"

    repository:

      include-directive:
        begin: ^[ ]*([s\-]?include)\b
        beginCaptures:
          "1": { name: keyword.control.include.makefile }
        end:   ^
        patterns:
        - include: "#comment"
        - include: "#expansions"
        - match: '%'
          name: constant.other.placeholder.makefile

      load:
        patterns:
        - comment: TODO placeholder

      vpath:
        begin: ^[ ]*(vpath)\b
        beginCaptures:
          "1": { name: keyword.control.vpath.makefile }
        end:   ^
        patterns:
        - include: "#comment"
        - include: "#expansions"
        - match: '%'
          name: constant.other.placeholder.makefile
        - match: ':'
          name: punctuation.separator.paths.vpath.makefile

      define:
        begin: |-
          (?x)
          ^
          \s* \b(override\b)?        # "1", optional
          \s* \b(define  \b)         # "2", required
          \s*   (                    # "3", required
                  [^\s]+
                )
          \s*   (                    # "4", optional
                  (                    # optional prefix...
                  |   !
                  |  \+
                  |  \?
                  |   :?:?:?
                  )?
                  =                    # ...and "="
                )?
          (?=\s)
        beginCaptures:
          "1": { name: keyword.control.override.makefile }
          "2": { name: keyword.control.define.makefile }
          "3": { name: *SCOPE_varAsgn }
          "4": { name: keyword.operator.assignment.makefile }
        end: ^\s*(endef)\b
        endCaptures:
          "1": { name: keyword.control.endef.makefile }
        name: meta.scope.define.makefile
        patterns:
        - comment: |-
            detect comments in define head
          begin: \G(?!\n)
          end:   ^
          patterns:
          - include: "#comment"
        - include: "#define"
        - include: "#expansions"

      export:
        begin: ^[ ]*(export)\b
        beginCaptures:
          "1": { name: keyword.control.$1.makefile }
        end:   ^
        patterns:
        - include: "#comment"
        - include: "#variable-assignment"
        - { match: \S+, name: *SCOPE_var }

      override_private:
        begin: ^[ ]*(override|private)\b
        beginCaptures:
          "1": { name: keyword.control.$1.makefile }
        end:   ^
        patterns:
        - include: "#comment"
        - include: "#variable-assignment"

      unexport_undefine:
        begin: ^[ ]*(unexport|undefine)\b
        beginCaptures:
          "1": { name: keyword.control.$1.makefile }
        end:   ^
        patterns:
        - include: "#comment"
        - { match: \S+, name: *SCOPE_var }

      conditional:
        begin: ^\s*(ifeq|ifneq|ifdef|ifndef)(?=\s)
        captures:
          "1": { name: keyword.control.$1.makefile }
        end:   ^\s*(endif)\b
        name: meta.scope.conditional.makefile
        patterns:
        - begin: \G
          end:   ^
          name: meta.scope.condition.makefile
          patterns:
          - include: "#comma"
          - include: "#expansions"
          - include: "#comment"
        - begin: ^\s*else(?=\s)\s*(ifeq|ifneq|ifdef|ifndef)*(?=\s)
          beginCaptures:
            "0": { name: keyword.control.else.makefile }
          end:   ^
          patterns:
          - include: "#comma"
          - include: "#expansions"
          - include: "#comment"
        - include: $self


# ----------------------- var assignment ---------------------- #

  __varAssignBegin:
    match: &__varAssignBegin |-
      (?x)
      (?:  ^[\ ]*|\G\s*  )  # discard leading whitespace
      (    [^\s:#=]+     )  # group 1; the variable name
      \s*                   # any space between name and assignment operator
                            # assignment operators:
      ( (?<![?:+!])   =     #    =
      |              !=     #   !=
      |             \+=     #   +=
      |             \?=     #   ?=
      |              :=     #   :=
      |             ::=     #  ::=
      |            :::=     # :::=
      )

  variable-assignment:
    begin: *__varAssignBegin
    beginCaptures:
      "1":
        name: *SCOPE_varAsgn
        patterns:
        - include: "#expansions"
      "2": { name: keyword.operator.assignment.makefile }
    end: \n
    name: meta.expression.assignment.makefile
    patterns:
    - { match: \\$, name: *SCOPE_lineCont }
    - include: "#comment"
    - include: "#expansions"


# --------------------------- rules --------------------------- #

  __ruleheadBegin:
    match: &__ruleheadBegin |-
      (?x)
      ^(?!\t)    # recipe line - fail the match
      [ ]*       # eat leading whitespace
      ( # "1": name of target(s)
        [^:]*
      )
      ( # "2": the separator after the target(s)
         ::
      |  :
      | &::
      | &:
      )
      (?!\=)     # the : was part of ':=' -> assignment -> fail the match!

  rulehead:
    name: meta.scope.rulehead.makefile
    begin: *__ruleheadBegin
    beginCaptures:
      "1":
        name: meta.scope.targets.makefile
        patterns:
        - match: '[ ]+'
        - comment: special target
          captures: { "1": { name: support.function.target.$1.makefile } }
          match: '(?x)
            ^
            \s*
            (?# special targets: )
            ( \.DEFAULT
            | \.DELETE_ON_ERROR
            | \.EXPORT_ALL_VARIABLES
            | \.IGNORE
            | \.INTERMEDIATE
            | \.LOW_RESOLUTION_TIME
            | \.NOTINTERMEDIATE
            | \.NOTPARALLEL
            | \.ONESHELL
            | \.PHONY
            | \.POSIX
            | \.PRECIOUS
            | \.SECONDARY
            | \.SECONDEXPANSION
            | \.SILENT
            | \.SUFFIXES
            | \.WAIT
            )
            \s*
            $'
        - comment: a target, possibly with expansion(s)
          begin: (?<![^ ])
          end:   \z|(?=[ ])
          name: entity.name.function.target.makefile
          patterns:
          - include: "#expansions"
          - match: '%'
            name: constant.other.placeholder.makefile
      "2": { name: punctuation.separator.key-value.rulehead.makefile }
    end:   '[^\\]$'
    patterns:
    - begin: \G(?!\n|;)
      end:   (?=[^\\])$
      contentName: meta.scope.prerequisites.makefile
      patterns:
      - match: '[ ]+'
      - { match: \\\n, name: *SCOPE_lineCont }
      - match: '%|\*'
        name: constant.other.placeholder.makefile
      - include: "#comment"
      - include: "#expansions"

  recipe:
    name: *SCOPE_recipe__
    comment: TODO placeholder

  recipe-line:
    name: *SCOPE_recipeLN
    begin: ^[\t]([+\-@]*)
    beginCaptures:
      "1": { name: keyword.control.$1.makefile
                   keyword.control.recipe-lineprefix.makefile }
    end:   '[^\\]$'
    patterns:
    - { match: \\\n, name: *SCOPE_lineCont }
    - include: "#expansions"


# ------------------------- expansions ------------------------ #

  # rule naming conventions
    # examples:
    #   _$p..p_           <=>  captures $(..)
    #   $p_var-builtin_p  <=>  captures <builtin-var> in $(<builtin-var>)

  expansions:
    comment: entry point for all searches for variable expansions
    patterns:
    - include: "#doubleDollar"
    - include: "#expansions-_$c_"
    - include: "#expansions-_$p..p_"
    - include: "#expansions-_$b..b_"

  expansions-_$c_:
    match: (\$)([^({$#\n ])
    captures:
      "1": { name: punctuation.definition.variable.makefile }
      "2": { name: variable.language.makefile }

  expansions-_$p..p_:
    patterns:
    - begin: (?x) \$\(
      captures:
        "0": { name: punctuation.definition.variable.makefile }
      end:   (?x)   \) | (?<!\\)\n
      name: string.interpolated.makefile
      patterns:
      - include: "#expansions"
      - include: "#expansions-$p_var-builtin_p"
      - include: "#expansions-$p_func-builtin_..p"
      - include: "#expansions-$p_func-builtin_flavor.._p"
      - include: "#expansions-$p_text_p"

  expansions-_$b..b_:
    patterns:
    - begin: (?x) \$\{
      captures:
        "0": { name: punctuation.definition.variable.makefile }
      end:   (?x)   \} | (?<!\\)\n
      name: string.interpolated.makefile
      patterns:
      - include: "#expansions"
      - include: "#expansions-$b_var-builtin_b"
      - include: "#expansions-$b_func-builtin_..b"
      - include: "#expansions-$b_func-builtin_flavor.._b"
      - include: "#expansions-$b_text_b"

  expansions-$p_var-builtin_p:
    patterns:
    - comment: special variables -> parens -> mutable
      match: (?<=\()(MAKEFILES|VPATH|SHELL|MAKESHELL|MAKE|MAKEFLAGS|MAKECMDGOALS|SUFFIXES|MAKE_TERMOUT|MAKE_TERMERR|\.LIBPATTERNS|\.DEFAULT_GOAL|\.RECIPEPREFIX\.EXTRA_PREREQS)(?=\s*\))
      name: variable.language.readwrite.makefile
    - comment: special variables -> parens -> immutable
      match: (?<=\()(MAKEFILE_LIST|MAKELEVEL|CURDIR|MAKE_RESTARTS|\.VARIABLES|\.FEATURES|\.INCLUDE_DIRS)(?=\s*\))
      name: variable.language.constant.makefile

  expansions-$b_var-builtin_b:
    comment: TODO distinguish mutable and immutable
    patterns:
    - comment: special variables -> braces -> mutable+immutable
      match: (?<={)(MAKEFILES|VPATH|SHELL|MAKESHELL|MAKE|MAKELEVEL|MAKEFLAGS|MAKECMDGOALS|CURDIR|SUFFIXES|\.LIBPATTERNS)(?=\s*})
      name: variable.language.makefile

  expansions-$p_func-builtin_..p:
    patterns:
    - begin: |-
        (?x)
        (?<= \( )
        (?# built-in functions -> parens: )
        (?# ref.: function.c -> struct function_table_entry + guile)
        ( abspath
        | addprefix
        | addsuffix
        | and
        | basename
        | call
        | dir
        | error
        | eval
        | file
        | filter
        | filter-out
        | findstring
        | firstword
        | foreach
        | guile
        | if
        | info
        | intcmp
        | join
        | lastword
        | let
        | notdir
        | or
        | patsubst
        | realpath
        | shell
        | sort
        | strip
        | subst
        | suffix
        | value
        | warning
        | wildcard
        | word
        | wordlist
        | words
        )
        (?:[ ]|(?=\\ \n))
      beginCaptures:
        "1": { name: support.function.$1.makefile }
      end: (?=\)|((?<!\\)\n))
      name: meta.scope.function-call.makefile
      patterns:
      - include: "#comma"
      - include: "#expansions"
      - include: "#expansions--func-builtin-NESTED"
      - match: '%|\*'
        name: constant.other.placeholder.makefile
      - { match: \\\n, name: *SCOPE_lineCont }

  expansions-$b_func-builtin_..b:
    patterns:
    - begin: |-
        (?x)
        (?<= { )
        (?# built-in functions -> braces: )
        ( abspath
        | addprefix
        | addsuffix
        | and
        | basename
        | call
        | dir
        | error
        | eval
        | file
        | filter
        | filter-out
        | findstring
        | firstword
        | foreach
        | guile
        | if
        | info
        | intcmp
        | join
        | lastword
        | let
        | notdir
        | or
        | patsubst
        | realpath
        | shell
        | sort
        | strip
        | subst
        | suffix
        | value
        | warning
        | wildcard
        | word
        | wordlist
        | words
        )
        (?:[ ]|(?=\\ \n))
      beginCaptures:
        "1": { name: support.function.$1.makefile }
      end: (?=}|(?<!\\)\n)
      name: meta.scope.function-call.makefile
      patterns:
      - include: "#comma"
      - include: "#expansions"
      - include: "#expansions--func-builtin-NESTED"
      - match: '%|\*'
        name: constant.other.placeholder.makefile
      - { match: \\\n, name: *SCOPE_lineCont }

  expansions--func-builtin-NESTED:
    patterns:
    - include: "#expansions--func-builtin-NESTED-pp"
    - include: "#expansions--func-builtin-NESTED-bb"
    comment: |-
      the "*NESTED*" rules:
      * intended to track nested (..)s and {..}s in function arguments
      * example:
          `$(info a(b)c)` -> GNU make prints "a(b)c"
          i.e. ")" after "b" does _not_ end the argument to `info`
      * previously had names "*interpolation*"

  expansions--func-builtin-NESTED-pp:
    begin: (?x) \(
    end:   (?x) \) | (?<!\\)(?=\n)
    patterns:
    - include: "#expansions"
    - include: "#expansions--func-builtin-NESTED"

  expansions--func-builtin-NESTED-bb:
    begin: (?x) \{
    end:   (?x) \} | (?<!\\)(?=\n)
    patterns:
    - include: "#expansions"
    - include: "#expansions--func-builtin-NESTED"

  expansions-$p_func-builtin_flavor.._p:
    patterns:
    - begin: (?<=\()(origin|flavor)\s(?=[^\s)]+\s*\))
      contentName: *SCOPE_var
      beginCaptures:
        "1": { name: support.function.$1.makefile }
      end:   (?=\))
      name: meta.scope.function-call.makefile
      patterns:
      - include: "#expansions"

  expansions-$b_func-builtin_flavor.._b:
    patterns:
    - begin: (?<={)(origin|flavor)\s(?=[^\s}]+\s*})
      contentName: *SCOPE_var
      beginCaptures:
        "1": { name: support.function.$1.makefile }
      end:   (?=})
      name: meta.scope.function-call.makefile
      patterns:
      - include: "#expansions"

  expansions-$p_text_p:
    patterns:
    - begin: (?x) (?<=\()   (?! \))
      end:   (?x) (?= \)|(?<!\\)\n )
      name: *SCOPE_var
      patterns:
      - include: "#expansions"
      - { match: \\\n, name: *SCOPE_lineCont }

  expansions-$b_text_b:
    patterns:
    - begin: (?x) (?<=\{)   (?! \})
      end:   (?x) (?= \}|(?<!\\)\n )
      name: *SCOPE_var
      patterns:
      - include: "#expansions"
      - { match: \\\n, name: *SCOPE_lineCont }
